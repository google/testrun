#!/bin/bash

# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#set -o xtrace
ip a
TEST_DIR=/tmp/results
TESTRUN_DIR=/usr/local/testrun
MATRIX=testing/tests/test_tests.json

rm -rf $TEST_DIR/
mkdir -p $TEST_DIR

# Setup requirements
sudo apt-get update
sudo apt-get install -y openvswitch-common openvswitch-switch tcpdump jq moreutils coreutils isc-dhcp-client

pip3 install pytest==7.4.4

# Start OVS
# Setup device network
sudo ip link add dev xyz type dummy
sudo ip link add dev endev0a type veth peer name endev0b
sudo ip link set dev endev0a up
sudo ip link set dev endev0b up
sudo docker network remove endev0
sudo docker network create -d macvlan -o parent=endev0b endev0

sudo /usr/share/openvswitch/scripts/ovs-ctl start

# Build Test Container
sudo docker build ./testing/docker/test_device_4 -t test_device_4 -f  ./testing/docker/test_device_4/Dockerfile

# Copy configuration to testrun
sudo cp testing/tests/system.json $TESTRUN_DIR/local/system.json

# Copy device configs to testrun
sudo cp -r testing/device_configs/* $TESTRUN_DIR/local/devices

testrun_log=$TEST_DIR/test_device_4_testrun.log
device_log=$TEST_DIR/test_device_4_device.log

# Start Testrun
touch $testrun_log

sudo timeout 900 testrun --single-intf --no-ui > $testrun_log 2>&1 &
TPID=$!

# Time to wait for testrun to be ready
WAITING=700

# Wait until Testrun is 'Waiting for Devices'
for i in `seq 1 $WAITING`; do

  tail -1 $testrun_log
  if [[ -n $(fgrep "Waiting for devices on the network" $testrun_log) ]]; then
    break
  fi

  # Check if Testrun process has exited
  if [[ ! -d /proc/$TPID ]]; then
      cat $testrun_log
      echo "Error encountered starting test run"
      exit 1
  fi

  sleep 1

done

# Testrun failed to startup within timeout
if [[ $i -eq $WAITING ]]; then
    cat $testrun_log
    echo "Failed after waiting $WAITING seconds for testrun to start"
    exit 1
fi

# Helps unclean exits when running locally
sudo docker stop test_device_4 && sudo docker rm test_device_4

# Load Test Container
sudo docker run -d \
  --network=endev0 \
  --mac-address="60:70:6c:00:00:04" \
  --cap-add=NET_ADMIN \
  -v /tmp:/out \
  --privileged \
  --rm \
  --name=test_device_4 \
  test_device_4

WAITING=600


for i in `seq 1 $WAITING`; do
  tail -1 $testrun_log
  if [[ -n $(fgrep "All tests complete" $testrun_log) ]]; then
    sleep 10
    sudo kill -9 $TPID
  fi

  if [[ ! -d /proc/$TPID ]]; then
    break
  fi

  sleep 1
done

# Following line indicates that tests are completed but wait till it exits
# Completed running test modules on device with mac addr 7e:41:12:d2:35:6a

# more runtime/network/*.log | cat 
# sudo docker logs test_device_4 | cat

# Stop the test device now that we don't need it
sudo docker kill test_device_4

cp $TESTRUN_DIR/runtime/test/60706c000004/report.json $TEST_DIR/test_device_4.json
more $TEST_DIR/test_device_4.json | cat

more $testrun_log | cat



#################################################################################################################

# Build Test Container
sudo docker build ./testing/docker/test_device_5 -t test_device_5 -f  ./testing/docker/test_device_5/Dockerfile

# Copy configuration to testrun
sudo cp testing/tests/system.json $TESTRUN_DIR/local/system.json

# Copy device configs to testrun
sudo cp -r testing/device_configs/* $TESTRUN_DIR/local/devices

testrun_log=$TEST_DIR/test_device_5_testrun.log
device_log=$TEST_DIR/test_device_5_device.log

# Start Testrun
touch $testrun_log

sudo timeout 900 testrun --single-intf --no-ui > $testrun_log 2>&1 &
TPID=$!

# Time to wait for testrun to be ready
WAITING=700

# Wait until Testrun is 'Waiting for Devices'
for i in `seq 1 $WAITING`; do

  tail -1 $testrun_log
  if [[ -n $(fgrep "Waiting for devices on the network" $testrun_log) ]]; then
    break
  fi

  # Check if Testrun process has exited
  if [[ ! -d /proc/$TPID ]]; then
      cat $testrun_log
      echo "Error encountered starting test run"
      exit 1
  fi

  sleep 1

done

# Testrun failed to startup within timeout
if [[ $i -eq $WAITING ]]; then
    cat $testrun_log
    echo "Failed after waiting $WAITING seconds for testrun to start"
    exit 1
fi

# Helps unclean exits when running locally
sudo docker stop test_device_5 && sudo docker rm test_device_5

# Load Test Container
sudo docker run -d \
  --network=endev0 \
  --mac-address="02:42:aa:00:00:05" \
  --cap-add=NET_ADMIN \
  -v /tmp:/out \
  --privileged \
  --rm \
  --name=test_device_5 \
  test_device_5

WAITING=600


for i in `seq 1 $WAITING`; do
  tail -1 $testrun_log
  if [[ -n $(fgrep "All tests complete" $testrun_log) ]]; then
    sleep 10
    sudo kill -9 $TPID
  fi

  if [[ ! -d /proc/$TPID ]]; then
    break
  fi

  sleep 1
done

# Following line indicates that tests are completed but wait till it exits
# Completed running test modules on device with mac addr 7e:41:12:d2:35:6a

# more runtime/network/*.log | cat 
# sudo docker logs test_device_5 | cat

# Stop the test device now that we don't need it
sudo docker kill test_device_5

cp $TESTRUN_DIR/runtime/test/0242aa000005/report.json $TEST_DIR/test_device_5.json
more $TEST_DIR/test_device_5.json | cat

more $testrun_log | cat

# Use pytest to verify results
pytest -v testing/tests/test_tests.py


exit $?